using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UIElements;

/*
 * 쉐이더란?
 * - 화면 상에 출력되는 픽셀의 색상을 계산하기 위한 도구를 의미한다. (즉,
 * 쉐이더를 활용하면 화면 상에 출력 될 물체의 표면에 대한 재질을 표현하는
 * 것이 가능하다.)
 * 
 * 또한, 쉐이더는 일반적인 프로그램과 달리 GPU 에 의해서 실행되기 때문에
 * GPU 상에 구동되는 프로그램이기도 하다.
 * 
 * 쉐이더는 렌더링 파이프라인의 특정 단계를 커스텀하게 제어 할 수 있는
 * 수단이기 때문에 쉐이더를 활용하면 다양한 결과물을 화면 상에 출력하는
 * 것이 가능하다. (즉, 렌더링 파이프라인은 고정 파이프라인과 프로그래머블
 * 파이프라인으로 나뉘며 이중 쉐이더는 프로그래머블 파이프라인과 연관이
 * 있다는 것을 알 수 있다.)
 * 
 * 렌더링 파이프라인이란?
 * - 3 차원 공간 상에 배치 된 물체가 화면 상에 출력되기 위해서 거치는 일련의
 * 단계를 의미한다. (즉, Unity 씬 상에 배치 된 물체가 화면 상에 출력되기
 * 위해서 많은 연산이 필요하다는 것을 알 수 있다.)
 * 
 * 렌더링 파이프라인 종류
 * - 고정 렌더링 파이프라인
 * - 프로그래머블 렌더링 파이프라인
 * 
 * 고정 렌더핑 파이프라인 vs 프로그래머블 렌더링 파이프라인
 * - 고정 렌더링 파이프라인은 특정 단계를 커스텀하게 제어하는 것은 불가능하며
 * 해당 파이프라인을 제작한 밴더 사에서 제공해주는 옵션의 조합으로 물체의
 * 표면을 제한적으로 표현 할 수 있다는 단점이 존재한다.
 * 
 * 반면, 프로그래머블 파이프라인은 특정 단계를 커스텀하게 제어하는 것이
 * 가능하며 해당 단계를 제어하기 위한 수단으로 쉐이더가 사용된다. (즉,
 * 쉐이더를 활용하면 특정 단계를 커스텀하게 제어함으로서 다양한 결과물을
 * 만들어내는 것이 가능하다.)
 * 
 * 렌더링 파이프라인 주요 연산 종류
 * - 정점 연산
 * - 래스터라이즈 연산
 * - 픽셀 (프래그먼트) 연산
 * 
 * 정점 연산이란?
 * - 3 차원 공간 상에 존재하는 정점 정보를 2 차원으로 변환하는 연산을
 * 의미하며 해당 단계는 정점 쉐이더에 의해서 처리된다. (즉, 정점 연산 단계를
 * 커스텀하게 제어하고 싶다면 정점 쉐이더를 제작하면 된다는 것을 알 수 있다.)
 * 
 * 래스터라이즈 연산이란?
 * - 정점 연산에 의해서 계산 된 물체의 표면을 연산하는 단계를 의미하며
 * 해당 단계는 그래픽 카드 전용 연산이기 때문에 해당 단계는 커스텀하게 제어
 * 하는 것이 불가능하다. (즉, 래스터라이즈 연산 단계를 거치면 물체의 색상을
 * 계산하기 위한 픽셀이 결정된다는 것을 알 수 있다.)
 * 
 * 픽셀 연산이란?
 * - 래스터라이즈 단계에 의해 결정 된 픽셀의 색상을 연산하는 단계의 의미한다.
 * (즉, 해당 단계를 거치고 나면 화면 상에 출력 될 물체의 색상이 결정된다는
 * 것을 알 수 있다.)
 * 
 * 또한, 해당 단계는 픽셀 쉐이더에 의해서 처리 되기 때문에 해당 단계를
 * 커스텀하게 제어하고 싶다면 픽셀 쉐이더를 제작하면 된다는 것을 알 수 있다.
 * 
 * Unity 가 지원하는 쉐이더 제작 방식 종류
 * - Shader Lab
 * - Vertex / Fragment Shader
 * - Surface Shader
 * - Shader Graph
 * 
 * Shader Lab 이란?
 * - Unity 가 자체적으로 지원하는 쉐이더 제작 언어로서 해당 방식을 사용하면
 * 간단하게 쉐이더를 제작하는 것이 가능하다.
 * 
 * 단, 해당 방식은 제작 할 수 있는 쉐이더의 기능이 제한적이기 때문에 요즘에
 * 사용되지 않는다는 특징이 존재한다. (즉, 해당 방식은 호환성을 위해서
 * 존재한다는 것을 알 수 있다.)
 * 
 * Vertex / Fragment Shader 란?
 * - 쉐이더를 제작하기 위한 전통적인 방식으로서 해당 방식을 통해 쉐이더를
 * 제작하면 퀄리티 좋은 결과물을 만들어내는 것이 가능하다.
 * 
 * 단, 해당 방식은 컴퓨터 그래픽스에 대한 높은 이해도를 요구하기 때문에
 * 숙련 된 사용자가 아니라면 쉐이더를 제작하는데 어려움이 있다는 것을 
 * 알 수 있다.
 * 
 * Surface Shader 란?
 * - Vertex / Fragment 방식에 비해 비교적 수월하게 퀄리티 좋은 쉐이더를
 * 제작 할 수 있는 방식을 의미한다. (즉, 해당 방식으로 제작 된 쉐이더는
 * 비교적 좋은 성능으로 동작한다는 것을 알 수 있다.)
 * 
 * Surface Shader 방식은 Vertex / Fragmet 방식에 비해 요구하는 그래픽스 
 * 이해도가 낮기 때문에 현재도 자주 활용되는 쉐이더 제작 방식이다.
 * 
 * Shader Graph 란?
 * - 명령문을 통해서 쉐이더를 제작하는 다른 방식에 비해 명령문을 모른다고
 * 하더라도 쉐이더를 제작 할 수 있는 방식을 의미한다. (즉, 쉐이더를 제작하기
 * 위한 명령문을 필요로 하지 않기 때문에 아트 파트와 같은 프로그래머가 아닌
 * 사용자도 쉐이더를 제작하는 것이 가능하다.)
 * 
 * 단, Unity 에서 Shader Graph 방식을 사용하기 위해서는 URP or HDRP 를
 * 요구하기 때문에 Built in 렌더링 파이프라인에서는 해당 방식을 통한
 * 쉐이더 제작이 불가능하다는 단점이 존재한다.
 * 
 * Unity 렌더링 파이프라인 종류
 * - Built in
 * - Universal
 * - High Definition
 * 
 * Built in 렌더링 파이프라인이란?
 * - Unity 가 기본적으로 지원하는 렌더링 파이프라인을 의미한다. (즉, Unity
 * 프로젝트를 생성 할 경우 기본적으로 내장 되어있다는 것을 알 수 있다.)
 * 
 * 해당 파이프라인은 Unity 초기 시절부터 지원하는 파이프라인이기 때문에
 * 다른 파이프라인에 비해 안정성이 높다는 장점이 존재한다. (단, 많은 기능을
 * 제공하기 때문에 최적화에 대한 여러가지 노하우가 필요하는 단점이 존재한다.)
 * 
 * Universal 렌더링 파이프라인이란?
 * - 스크립터블 렌더링 파이프라인을 비교적 쉬원 방법으로 커스텀하게 제어할
 * 수 있는 렌더링 파이프라인을 의미한다. 
 * 
 * 또한, 해당 파이프라인은 Built in 파이프라인에 비해 가볍다는 특징이
 * 존재하기 때문에 모바일과 같은 하드웨어 성능이 상대적으로 떨어지는 플랫폼에
 * 최적화 되어있다는 특징이 존재한다. (즉, Built in 파이프라인에 비해
 * 고성능을 요구하는 몇가지 기능들이 제외되었다는 것을 알 수 있다.)
 * 
 * High Definition 렌더링 파이프라인이란?
 * - Universal 과 달리 하이 엔드 스펙에 동작하는 프로그램을 제작 할 수 있는
 * 렌더링 파이프라인을 의미한다. (즉, 해당 파이프라인은 고성능 그래픽을
 * 만들어내는 것이 가능하지만 높은 하드웨어 스펙을 요구한다는 것을 알 수
 * 있다.)
 * 
 * 해당 파이프라인 또한 스크립터블 렌더링 파이프라인을 비교적 쉽게 제어하기
 * 위한 파이프라인이라는 것을 알 수 있다.
 */
/** Example 16 */
public class CE01Example_16 : CSceneManager
{
	#region 변수
	[SerializeField] private GameObject m_oTargetRoot = null;
	#endregion // 변수

	#region 프로퍼티
	public override string SceneName => KDefine.G_SCENE_N_EXAMPLE_16;
	#endregion // 프로퍼티

	#region 함수
	/** 초기화 */
	public override void Awake()
	{
		base.Awake();
	}

	/** 상태를 갱신한다 */
	public override void OnUpdate(float a_fDeltaTime)
	{
		base.OnUpdate(a_fDeltaTime);

		for(int i = 0; i < m_oTargetRoot.transform.childCount; ++i)
		{
			var oChild = m_oTargetRoot.transform.GetChild(i);
			oChild.Rotate(Vector3.up, 90.0f * a_fDeltaTime, Space.World);
		}
	}
	#endregion // 함수
}
